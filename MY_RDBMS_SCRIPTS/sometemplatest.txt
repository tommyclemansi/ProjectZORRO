create shapshots:
-----------------
1. create a snapshot with : exec dbms_workload_repository.create_snapshot; 
2. run the Java application
3. create a new snapshot : exec dbms_workload_repository.create_snapshot; 
4. create the awr report : @rdbms/admin/awrrpt.sql;

troubleshoot hangs:
-------------------
+ ON RAC   
- open a sqlplus SYSDBA connection to dump systemstates:
  (if you can't connect see 359536.1 for an explanation on the -prelim option)
    SQL> connect /as sysdba
    SQL> oradebug setmypid
    SQL> oradebug unlimit
- when the hang happens, use the above sqlplus from one of the instances to get the dumps
    SQL> oradebug -g all hanganalyze 3
    2 minutes
    SQL> oradebug -g all hanganalyze 3
    2 minutes
    SQL> oradebug -g all hanganalyze 3
    2 minutes
    SQL> oradebug -g all dump systemstate 266
    SQL> oradebug -g all dump systemstate 266
    SQL> oradebug -g all dump systemstate 266
- now pick up alert.logs and all tracefiles generated or updated on all instances during the time the above commands where running, zip & upload

+ SINGLE INSTANCE
- open a sqlplus SYSDBA connection to dump systemstates:
  (if you can't connect see 359536.1 for an explanation on the -prelim option)
    SQL> connect /as sysdba
    SQL> oradebug setmypid
    SQL> oradebug unlimit
- when the hang happens, use the above sqlplus from one of the instances to get the dumps
    SQL> oradebug hanganalyze 3
    2 minutes
    SQL> oradebug hanganalyze 3
    2 minutes
    SQL> oradebug hanganalyze 3
    2 minutes
    SQL> oradebug dump systemstate 266
    SQL> oradebug dump systemstate 266
    SQL> oradebug dump systemstate 266


- now pick up alert.logs and all tracefiles generated or updated on all instances during the time the above commands where running, zip & upload

     Errorstacks

    First find the session id and OS process id 
    
    * For this session:
    select p.pid,p.spid,s.sid from v$process p,v$session s where s.paddr = p.addr and s.audsid = userenv('SESSIONID');
        
    * When running the operation in another session you need to find the OS process id of that session.
    - First use v$session to get the paddr
    - Then select spid from v$process when addr=<paddr>;
    - This spid is the os process id
    select p.pid,p.spid,s.sid from v$process p,v$session s where s.paddr = p.addr and s.SID = <fill in the SID>
    
    Get a few (at least 3) errostacks from the hanging / spinning session
    Assuming that the shadow process id you wanted to dump has an o/s pid of 1234 (from the select before)
    
    login to SQL*Plus: in a different session
    
    connect / as sysdba
    oradebug setospid 1234
    oradebug unlimit
    oradebug dump errorstack 3
    <30 secs>
    oradebug dump errorstack 3
    <30 secs>
    oradebug dump errorstack 3
    
    This will produce a trace file in your user_dump_dest. Please upload the traces using metalink.



'll try to put a full action plan for when the issue would happen again.  Note that in case of a reproducable problem we can request more information (like sqlnet tracing), however since it is a production system, doing excessive tracing might slow down.  Therefor I tried to define a detailed action plan below.

Note that I don't know if the fix has to do with this issue.  the hang does not seem to occur on one of the functions included with the patch, instead it seems to be in waiting state on the socket.

1. Obtain client stack:
--------------------
obtain client side thread information:

1.1. do a kill -3 on the java process that is hanging
     Do this a couple of times to see if the state remains the same

1.2. do pthread <PID> on the java process that is hanging


2. obtain serverside information:
---------------------------------
The difficulty here is to find the sessionid for the process that corresponds to the thread on client side.  
For reproducable cases one could use DBMS_APPLICATION_INFO to programatically insert thread id and name into v$session.  
If this is not done programatically it can be sometimes difficult to find the serverside session and process.  

The following way we find is the easiest way to do this:

2.1. try to find a session that is in v$session_wait

You can use the following statements to try to find the session:

to include pid:
select s.sid, p.spid, w.event,s.username, s.program, w.state, w.p1,w.p2,w.p3,w.seconds_in_wait/60 as min_in_wait from v$session_wait w,v$session s,v$process p where w.sid=s.sid and s.paddr= p.addr order by min_in_wait desc;

limit user sessions:
select s.sid, p.spid, w.event,s.username, s.program, w.state, w.p1,w.p2,w.p3,w.seconds_in_wait/60 as min_in_wait from v$session_wait w,v$session s,v$process p where w.sid=s.sid and s.paddr= p.addr and s.type='USER' order by min_in_wait desc;

limit JDBC: (note not working with 10.1 & 10.2 drivers)
select s.sid, p.spid, w.event,s.username, s.program, w.state, w.p1,w.p2,w.p3,w.seconds_in_wait/60 as min_in_wait from v$session_wait w,v$session s,v$process p where w.sid=s.sid and s.paddr= p.addr and s.type='USER' and upper(s.program) like '%JDBC%' order by min_in_wait desc;

include also serial:
select s.sid, p.spid, s.serial#, w.event,s.username, s.program, w.state, w.p1,w.p2,w.p3,w.seconds_in_wait/60 as min_in_wait from v$session_wait w,v$session s,v$process p where w.sid=s.sid and s.paddr= p.addr and s.type='USER' and upper(s.program) like '%JDBC%' order by min_in_wait desc;

limit machine , but also show last sql:
select s.sid, p.spid, s.machine,s.sql_id,l.sql_text,s.serial#, w.event,s.username, s.program, w.state, w.p1,w.p2,w.p3,w.seconds_in_wait/60 as min_in_wait from v$session_wait w,v$session s,v$process p , v$sqltext l where w.sid=s.sid and s.paddr= p.addr and s.type='USER' and upper(s.program) like '%JDBC%' and s.sql_address = l.address and l.hash_value = s.sql_hash_value and s.machine ='MACHINENAME' order by min_in_wait ;


If you find a session that matches the wait time of your client thread, you can try to get more information on that serverside process..

==> if you find the session id then update the output of one of the obove queries to the SR.. (so we know the wait event)

maybe best, user + last sql :
select s.sid, p.spid, w.event,s.username, s.program, w.state, w.p1,w.p2,w.p3,w.seconds_in_wait/60 as min_in_wait,l.sql_text from v$session_wait w,v$session s,v$process p ,v$sqltext l where w.sid=s.sid and s.paddr= p.addr and s.type='USER' and s.sql_address = l.address and l.hash_value = s.sql_hash_value order by min_in_wait desc, l.piece;

or specific for a certain wait event seen:
SELECT vs.inst_id,vs.osuser,vw.event,vw.p1,vw.p2,vw.p3 ,vt.sql_text , vs.program
FROM gv$session_wait vw, gv$sqltext vt , gv$session vs
WHERE vw.event = 'PL/SQL lock timer'
AND vt.address=vs.sql_address
AND vs.inst_id = vw.inst_id
AND vs.sid = vw.sid;

2.2. check what is the last statement executed:
select sql_text from v$sqltext_with_newlines where address= (select sql_address from v$session where sid=164) order by piece;
(where sid is sessionid found in above statements)

2.3.  the spid in above queries is the OS PID that corresponds to this session.

2.3.1. try first to get an strace/truss of the OS process.  On the dbserver do strace/truss <PID>   (using spid obtained in above queries)

2.3.2. get a pstack from the process

2.3.3. Get a few (at least 3) errostacks from the hanging / spinning session
       Assuming that the shadow process id you wanted to dump has an o/s pid of 1234 (from the select before)
    
login to SQL*Plus: in a different session
    
    connect / as sysdba
    oradebug setospid 1234
    oradebug unlimit
    oradebug dump errorstack 3
    <30 secs>
    oradebug dump errorstack 3
    <30 secs>
    oradebug dump errorstack 3
    

for jdbc thin client side sqlnet tracing & logging:
--------------------------------------------------------------------


reference to the documentation on logging:
http://www.oracle.com/technetwork/database/enterprise-edition/11-2.pdf

reference to the JDBC download page:
http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html

Basically:
You'll  need to use a ojdbcX_g.jar file. And additionally you can startup your java program with the -Doracle.jdbc.Trace option and with -Djava.util.logging.config.file, for example:
java -Doracle.jdbc.Trace=true -Djava.util.logging.config.file=D:\JDBC\drivers\Logging\log112.properties .. 

I  pasted below a sample content for the properties file. It should log what we need (net tracing + jdbc logging). In this way we check for any Exception and at the same time we can check what the client received from the network. (or from the server).
Note that I gave a sample maximum size of 50 mB, you can increase or decrease as you want.
start sample .properties file:
---------------------------------------------------------------------------------------------------
.level=SEVERE
oracle.level=FINEST
oracle.net.ns.level = FINEST
oracle.handlers=java.util.logging.FileHandler
java.util.logging.FileHandler.pattern=D:\\JDBC\\drivers\\Logging\\log112%u.log
java.util.logging.FileHandler.limit=50000000
java.util.logging.FileHandler.level=ALL
java.util.logging.FileHandler.count=10
java.util.logging.FileHandler.formatter=java.util.logging.XMLFormatter
oracle.jdbc.diagnostics.DemultiplexingLogHandler.pattern = D:\\JDBC\\drivers\\Logging\\sqlnet_%s.log
oracle.jdbc.diagnostics.DemultiplexingLogHandler.limit = 50000000
oracle.jdbc.diagnostics.DemultiplexingLogHandler.count = 1
oracle.jdbc.diagnostics.DemultiplexingLogHandler.formatter = java.util.logging.XMLFormatter
oracle.net.ns.handlers = oracle.jdbc.diagnostics.DemultiplexingLogHandler
-------------------------------------------------------------------------------------------------------------
If the exception has occurred the best would be to copy them directly and upload.  (else the mail log files might be overwritten). 
If you would code a System.exit upon failure (for example on a java.sql.SQLException) in your program, also include a sleep before that, so that it will give your JVM more time to write the JDBC logging information to disk. 
2. For serverside SQLNET tracing:
------------------------------------------------
2.1. Add the following parameters in the sqlnet.ora file on the SERVER:

TRACE_LEVEL_SERVER=16
TRACE_DIRECTORY_SERVER=<some_known_directory>
TRACE_FILE_SERVER=server
TRACE_TIMESTAMP_SERVER=ON

If you need to restrict the amount of disk space used by the long-term traces then you can also
set the following:

TRACE_FILELEN_SERVER=<file_size_in_Kbytes>
TRACE_FILENO_SERVER=<number_of_files>

2.2. Try to reproduce the issue - connect from the application to the database.

2.3. Check if trace files were created.

2.4. Disable tracing by removing the TRACE lines from sqlnet.ora on both CLIENT and SERVER.

2.5. Compress (in .zip or .tar.gz format) and upload the trace files.


enable ons logging:
-------------------
) Switch on logging and check if service metric events are being sent.

ONS version 11.2.0.1 has introduced a new method of logging or tracing ONS activities. On each node, edit ons.config.<node name> file and add the following parameter:

debugcomp=ons[subcomponent]

Valid subcomponents for ons are:

  all - all messages
  local - ONS local information
  listener - ONS listener information
  discover - ONS discover (server or multicast) information
  servers - ONS remote servers currently up and connected to the cluster
  topology - ONS current cluster wide server connection topology
  server - ONS remote server connection information
  client - ONS client connection information
  connect - ONS generic connection information
  subscribe - ONS client subscription information
message - ONS notification receiving and processing information
  deliver - ONS notification delivery information
special - ONS special notification processing
  internal - ONS internal resource information
 secure - ONS SSL operation information
  workers - ONS worker threads


For example, debugcomp=ons[all,!secure] logs all information except ONS SSL operations.

All the log information is written to the file ons.dbg.<node name>


JDBCLoggingWLS
--------------
Enabling JDBC Debugging
- in WebLogic admin console click on a server and then select the Debug tab
- expand the weblogic, check the jdbc and click on Enable  - this will enable all jdbc debugging
- you can also check some of jdbc debugging, expand the jdbc and check connection, driverlogging,internal, and transaction

- do not forget to change the log severity to Debug or Trace
 * in WebLogic admin console click on a server and then select the Logging tab
 * scroll down and click Advanced
 * change the "Minimum severity to log" to Debug or Trace and then Save 


CRS&SCAN LISTENER TRACING:
-=========================

1.3. For serverside logging.

Here I think the best that we do the logging for the SCAN listener.
I propose we do start with tracing only.  (we can also do sqlnet tracing, but at this point I'm not sure for how far you get with the connection itself (I assume there is no redirect yet that occurred from the scan to the vip listener)

To trace the SCAN listener you can adapt the listener.ora on serverside.
An example:

TRACE_LEVEL_LISTENER_SCAN1=16
TRACE_TIMESTAMP_LISTENER_SCAN1=TRUE
TRACE_DIRECTORY_LISTENER_SCAN1=/tmp/listenertrace
TRACE_FILELEN_LISTENER_SCAN1=500000
TRACE_FILENO_LISTENER_SCAN1=10

# below turns off diagnostics, if this is not done the files will be somewhere in diag directories and not in trace_directory
DIAG_ADR_ENABLED_LISTENER_SCAN1=off

For example:
Scan Listener, Queuesize, SDU, Ports (Doc ID 1292915.1)
Tracing Techniques for Listeners in 11.2 RAC Environments (Doc ID 1325284.1)

Note 952903.1 How to update the IP address of the SCAN VIP resources (ora.scan<n>.vip)
Note 975457.1 How to Troubleshoot Connectivity Issue with 11gR2 SCAN Name
Note 972500.1 How to Modify SCAN Setting after Installation
do not add more ports for scan:
Bug 10633024: SRVCTL ALLOWS SPECIFYING MORE THAN ONE PORT FOR SCAN (-P PORT1,PORT2,PORT3)

2. So once this is reproduced, best is to upload
2.1. you can upload then the client side traces
2.2. serverside scan listener logs & traces
2.3. also upload the node vip listener.logs & alert log files

2.4. Maybe for the CRS stack also upload
$gridhome\log\sg2pebtmd04\agent\crsd\oraagent_oracle\oraagent_oracle.log
$gridhome\log\sg2pebtmd04\agent\crsd\orarootagent_root\orarootagent_root.log
$gridhome\log\sg2pebtmd04\crsd\crsd.log
$gridhome\log\sg2pebtmd04\alert<SID>.log
