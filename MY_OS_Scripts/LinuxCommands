# tcleyman
# frequently used commands

# remove .trc files 
find . -name "*.trc" -type f | xargs rm -v

#remove log files
find . -name "*.log" -type f | xargs rm -v


# run in current shell
source setWLSenv.sh
. ./setWLSenv.sh

# Note
./setWLSEnv.sh on its own starts a new shell

# check last system messages
dmesg 

#find class files:
find . -type f -name '*.jar' -print0 |  xargs -0 -I '{}' sh -c 'jar tf {} | grep CSSUtils.class &&  echo {}'
find . -type f -name '*.jar' -print0 |  xargs -0 -I '{}' sh -c 'jar tf {} | grep NodeImpl.class &&  echo {}'

# in case of issues , log 

find . -type f -name '*.jar' | awk '
#tomsawk script, begins here 

find . -type f -name '*.jar' | awk '
#tomsawk script, begins here 
BEGIN {#FS= " \t"
count = 0
}
#main awk block, applies to all
{
myjar = $1
print "jar: " myjar
system(sprintf("jar tf %s", myjar ))
 count ++
}
END{print "no of jars : " count
print "end script"
}' 2>&1 | grep -B 1 "ZipException"

#find latest changed file
find . -type f -exec stat --format '%Y :%y %n' "{}" \; | sort -nr | cut -d: -f2- | head -n 30

# do some formatting/ sed based:

openssl dgst -md5  UserStore.xml | cut -d' ' -f2 | sed -e 's/[0-9,a-f]\{2\}/&:/g'
!! this is it
now at the end there is 
ef:9a:1a:bf:d3:3b:98:8b:dc:74:8b:9d:b9:0f:f5:49:


hmm all that work, seems digest may also be outputted with the columns
openssl dgst -md5  -c UserStore.xml | cut -d' ' -f2 

# check os limits
sysctl -a | grep ip_local_port_range

# global vars
/etc/profile

# check jobs
[root@tomssoabox ~]# crontab -u oracle -l
0,15,30,45 * * * * /u02/app/FMW11121/OHS1212/oracle_common/ccr/bin/emCCR -cron -silent start

[root@tomssoabox ~]# crontab -l
@reboot  echo "Server has restarted "`hostname` | mail -s "System Restart" tom.cleymans@oracle.com


cd /etc
ls cron*

# just grep 
find . -name "*.xml" | xargs grep "prefix.cert"
find . -name "*.json" | xargs grep "system.prefix.cert"

#sample awk for monitoring
ps -ef | grep vshell | awk '
#tomsawk script, begins here 
#applies to only first invocation
BEGIN {#FS= " \t"
count = 0
print "printing environment variables"
for (myenv in ENVIRON)
	print myenv ":" ENVIRON[myenv]
}
#main awk block, applies to all
{print "PID: " $2 " Type: " $8
 if ($8 !~ "grep")
     count ++
	 #store the PID in the array to be used later
	 myarray[count]=$2
}
END{print "no of processes: "  NR  " real number: " count
#now begin real script
print "begin script"
do 
{		echo "output " $_date
		for (i=1;i<=count;i++ )
			{ print "call shell script here"	
			  #pstack myarray[i]
			}
print "before sleep"
system("sleep 3")
print "after sleep"
}
while (true)
print "end script"
}'

#set prompt to current path:
export PS1='$(whoami)@$(hostname):$(pwd)>'

# count number of errors:
grep -cir "ERROR  " *.trc*
nodemanageronvipoegmgt01_8091.trc:0
nodemanageronvipoegmgt01_8091.trc.0:539
nodemanageronvipoegmgt01_8091.trc.1:312


# new, print the first and last line of a file, in order to know range file includes:
commands:
awk 'NR == 1 { print }END{ print }' filename
OR 
sed -e 7b -e '$!d' filename

# display first and last line:
xargs: -0 (new line for every, iso delimited by space, use it only when prev command uses NUL to delemit output)
       so only use this with print0
xargs: -I each line is buffered, and replaces each {}
xargs: -t output each line

# I used awk as seems to be easier:
# printed 7nt line due to the fact that first there is some header information
find . -type f -name '*.trc' -print0 | xargs -0 -I -t {} awk '{if(NR == 6) { print "filename: " FILENAME "\n" $2}} END { print $2}' {}

#without debug info:
find . -type f -name '*.trc*' -print0 | xargs -0 -I {} awk '{if(NR == 6) { print "filename: " FILENAME "\n" $2}} END { print $2}' {}

#only for current dir
ls *.trc* | xargs -I {} awk '{if(NR == 6) { print "filename: " FILENAME "\n" $2}} END { print $2}' {} 
sed -e 7b -e '$!d' *.trc

#final command used
 
find . -type f -name 'nodeman*.trc*' -print0 | xargs -0 -I {} awk '{if(NR == 6) { print FILENAME;for (i = 1; i <= length(FILENAME); i++) printf "=";print "\n" $2}} END { print $2 "\n"}' {}
find . -type f -name '*gw*.trc*' -print0 | xargs -0 -I {} awk '{if(NR == 6) { print FILENAME;for (i = 1; i <= length(FILENAME); i++) printf "=";print "\n" $2}} END { print $2 "\n"}' {}

#now include the number of errors
find . -type f -name 'nodeman*.trc*' -print0 | xargs -0 -I {} awk '{if($1 ~ /ERROR/){counter++};if(NR == 6) { print FILENAME;for (i = 1; i <= length(FILENAME); i++) printf "=";print "\n" $2}} END { print $2 "\nERRORS: " counter}' {}

find . -type f -name 'nodeman*.trc*' -print0 | xargs -0 -I {} awk 'BEGIN{counter=0}{if($1 ~ /ERROR/){counter++};if(NR == 6) { print FILENAME;for (i = 1; i <= length(FILENAME); i++) printf "=";print "\n" $2}} END { print $2 "\nERRORS: " counter}' {}

find . -type f -name 'nodeman*.trc*' -print0 | xargs -0 -I {} awk 'BEGIN{counter=0}{if($0 ~ /Connection failed/){counter++};if(NR == 6) { print FILENAME;for (i = 1; i <= length(FILENAME); i++) printf "=";print "\n" $2}} END { print $2 "\nERRORS: " counter}' {}

# only show starting position:
find . -type f -name 'nodeman*.trc*' -print0 | xargs -0 -I {} awk 'BEGIN{counter=0}{if($0 ~ /Connection failed/){counter++};if(NR == 6) { printf FILENAME " :\n" $2 " - " }} END { printf $2 " -  ERRORS: " counter "\n"}' {}

find . -type f -name '*gw*.trc*' -print0 | xargs -0 -I {} awk '{if(NR == 6) { printf FILENAME ": " $2}} END { printf " - "$2 "\n"}' {}
find . -type f -name '*gw*.trc*' -print0 | xargs -0 -I {} awk 'BEGIN{counter=0}{if($0 ~ /listen on/){counter++};if(NR == 6) { printf FILENAME " :\n" $2 " - " }} END { printf $2 " -  HITS: " counter "\n"}' {}


find . -type f -name 'nodeman*.trc*' -print0 | xargs -0 -I {} awk 'BEGIN{counter=0}{if($0 ~ /Connection failed/){counter++};if(NR == 6) { printf FILENAME " :\n" $2 " - " }} END { printf $2 " -  ERRORS: " counter "\n"}' {}

check mem:
#### start script
#!/bin/bash
# 04/02-  Tom Cleymans

# issue is to monitor the PSCcObjMgr_nld process
# monitor a process memory usage

# vars
TRACEDIR=/opt/siebinstall/tracing
MYHOST=$(hostname)

echo "Pres CTRL+C to stop..."
nldpid2=0
counter=0
nldpid=$1
# loop forever
for (( ; ; ))
do

#nldpid=$(/home/siebel/scripts/listprocs.sh | grep PSCcObjMgr_nld | cut -d'#' -f2 | sed 's/[^0-9]*//g')

# only if nldpid is nonzero we need to invoke code
if [ -n nldpid ]
then
TRACELOG=${TRACEDIR}/nldtrace_${MYHOST}${nldpid}.txt
TRACELOG2=${TRACEDIR}/nldtraceDET_${MYHOST}${nldpid}.txt
echo $TRACELOG

# take baseline if new process
if [ $nldpid != $nldpid2 ]
then
BASELINE=${TRACEDIR}/baseline_${MYHOST}${nldpid}.txt
echo "BASELINE: " > ${BASELINE}
date >> ${BASELINE}
echo "process status: "  >> ${BASELINE}
cat /proc/${nldpid}/status >> ${BASELINE}
echo "process map: " >> ${BASELINE}
cat /proc/${nldpid}/maps >> ${BASELINE}
fi

# block to execute every 60 secs
date >> ${TRACELOG}
ps -p $nldpid -o pid,cmd,etime,pcpu,stat,start_time,rss,size,sz,vsize,pmem >> ${TRACELOG}
echo "" >> ${TRACELOG}

fi

if [ $counter == 15 ]
then
# every X minutes do something more
# sysstat is enabled on machines
# this is just a guess that this is problematic
date >> ${TRACELOG2}
echo "libsscaadtbc.so LOADED: " >> ${TRACELOG2}
cat /proc/${nldpid}/maps | grep libsscaadtbc  >> ${TRACELOG2}

echo "THREADS: " >> ${TRACELOG2}
ps -p ${nldpid} -L -o pid,cmd,etime,pcpu,stat,start_time >> ${TRACELOG2}

echo "MACHINE MEMORY: " >> ${TRACELOG2}
free >> ${TRACELOG2}

echo "PROCESS STATUS: "  >> ${TRACELOG2}
cat /proc/${nldpid}/status >> ${TRACELOG2}

counter=0
fi

# wait 60 secs
sleep 1m
((counter++))
nldpid2==$(/home/siebel/scripts/listprocs.sh | grep PSCcObjMgr_nld | cut -d'#' -f2 | sed 's/[^0-9]*//g')
# end outer loop
done

#### end script


then monitor:
check growth of process:
grep 5419 nldtrace_s51lvds.cmcpp.be5419.txt | awk '
#tomsawk script, begins here 
#applies to only first invocation
BEGIN {#FS= " \t"
oldRSS=0
oldVS=0
counter=0
}
#main awk block, applies to all
{
# per 30 minutes print the difference in memory
if (counter>=30)
{
#print "RSS: " $9 "KB VSIZE: " $11 "KB"
print "DIFF: RSS: "KB $9-oldRSS " VSIZE: " $11-oldVS "KB"
oldRSS=$9
oldVS=$11
counter=0
}
counter++
}
END{
print "script completed"
}'
